

## 使用场景

---

| **类型**         | **语法示例**                 | **作用**               | **典型使用场景**                             | **注意事项**                      |
| ---------------------- | ---------------------------------- | ---------------------------- | -------------------------------------------------- | --------------------------------------- |
| **双下划线前后** | `__init__<br>``__name__`       | 实现特殊方法或标记特殊变量   | 定义构造函数、运算符重载`<br>`获取模块名称时     | 必须严格遵循 Python 预定义名称          |
| **双下划线文件** | `__init__.py<br>``__main__.py` | 标识 Python 包或定义执行入口 | 创建包时必含 `__init__.py<br>`制作可执行脚本包时 | 空 `__init__.py` 也可标识包           |
| **单下划线前缀** | `_internal_var`                  | 约定标记内部使用成员         | 模块内部变量/函数`<br>`类中非公开属性            | 无强制约束，`import *` 时会被忽略     |
| **双下划线前缀** | `__private_attr`                 | 强制名称改写防止继承冲突     | 类中需被子类隔离的属性                             | 实际存储为 `_ClassName__private_attr` |
| **无下划线**     | `public_method()`                | 公开接口                     | 对外提供的类方法、模块函数                         | 直接暴露，需谨慎设计                    |

---

### **快速选择指南**

1. **需要实现语言内置行为** → `__xxx__`（如 `__add__` 实现加法）
2. **保护类属性不被子类覆盖** → `__private`（触发名称改写）
3. **提示开发者不要直接访问** → `_internal`（约定优于强制）
4. **定义包或可执行模块** → `__init__.py` / `__main__.py`
5. **公开 API 设计** → 无下划线命名（如 `get_data()`）

---

### **对比示例**

```python
# 文件结构
my_package/
├── __init__.py     # 标识为包
├── __main__.py     # python -m my_package 时执行
└── module.py

# module.py 内容
class Employee:
    def __init__(self):
        self.__salary = 10000    # 改名为 _Employee__salary
        self._level = "P7"       # 内部职级标识
  
    def __calculate_bonus(self): # 改名为 _Employee__calculate_bonus
        pass
  
    def get_info(self):          # 公开方法
        return f"Level: {self._level}"

def _internal_check():           # 内部函数
    pass
```

---

通过此表可快速判断不同场景下的最佳实践，避免因下划线误用导致的维护问题。





## 特例

`__init__` 方法前后的双下划线（也称为"双下划线"或"dunder"）有特殊的意义，这是 Python 的命名约定的一部分。让我解释一下为什么有些方法需要双下划线而有些不需要：

### 前后双下划线 `__method__`

1. **特殊方法/魔术方法** ：这些方法在 Python 中有预定义的特殊含义，被解释器自动调用。
2. **Python 内置行为** ：它们定义了类如何响应内置操作。
3. **保留名称** ：这些名称被 Python 保留用于特定用途。

常见的双下划线方法包括：

* `__init__`: 构造函数，创建对象时自动调用
* `__str__`: 定义 `str(object)` 的行为
* `__repr__`: 定义对象的字符串表示
* `__len__`: 定义 `len(object)` 的行为
* `__add__`: 定义 `+` 运算符的行为

例如：

```python
class Person:
    def __init__(self, name):  # 构造函数
        self.name = name
    
    def __str__(self):  # 字符串表示
        return f"Person: {self.name}"
```

### 没有双下划线的方法

1. **普通方法** ：这些是你自己定义的常规类方法。
2. **自定义行为** ：表示类的特定功能，不是 Python 内置操作的一部分。
3. **显式调用** ：这些方法需要显式调用，不会被 Python 自动调用。

例如：

```python
class Person:
    def __init__(self, name):  # 特殊方法 - 构造函数
        self.name = name
    
    def greet(self):  # 普通方法 - 需要显式调用
        return f"Hello, my name is {self.name}"
```

使用：

```python
p = Person("Alice")  # __init__ 自动调用
print(p.greet())     # greet() 需要显式调用
```

### 单下划线前缀 `_method`

虽然你没有问到，但为了完整性，单下划线前缀也值得提一下：

```python
class Person:
    def __init__(self, name):
        self.name = name
        self._age = 30  # 表示这是一个"内部"属性
    
    def _internal_method(self):  # 表示这是一个"内部"方法
        return "This is intended for internal use"
```

单下划线表示该属性或方法是"内部"的，不是公共 API 的一部分，但这只是一种约定，并不强制执行。

### 总结

1. **`__method__`** (双下划线前后)：特殊方法，由 Python 解释器自动调用，实现内置行为
2. **`method`** (无特殊符号)：普通方法，表示类的自定义功能
3. **`_method`** (单下划线前缀)：约定表示内部/私有方法，不是公共 API 的一部分

`__init__` 使用双下划线是因为它是一个特殊方法，在对象创建时自动调用，是 Python 语言设计的一部分。


## 示例


```python
"""
假设这是一个公司的管理模块（company.py）
用代码对应公司各个部分的比喻
"""

# ==================== 1. 双下划线文件 ====================
# 文件 __init__.py → 公司前台（标识这是一个包）
# 文件 __main__.py → CEO办公室（执行入口）

print("\n=== 公司开张啦！门口挂上 __init__.py 招牌 ===")

# ==================== 2. 双下划线方法 ====================
class 公司:
    """ 公司本体，对应特殊方法 """
    def __init__(self, 名称):
        """ 自动门：新人入职自动触发 """
        print(f"[自动门] 欢迎来到{名称}！")
        self.__预算 = 1000000  # 双下划线前缀 → 财务部保险柜
        self._内部规定 = "禁止摸鱼"  # 单下划线 → 内部告示
        self.公共设施 = "咖啡机"     # 无下划线 → 公共区域
  
    def __发工资(self):  
        """ 双下划线前缀方法 → 财务部加密流程 """
        print("[保险柜] 正在通过 _公司__发工资 流程...")
  
    def 公开操作(self):
        """ 公共API → 大堂服务台 """
        print(f"[公共区域] 请使用{self.公共设施}")
        self.__发工资()  # 内部调用保险柜操作
  
    def __str__(self):
        """ 双下划线方法 → 公司宣传屏 """
        return f"=== 公司公告：{self._内部规定} ==="

# ==================== 3. 单下划线使用 ====================
def _内部审计():
    """ 单下划线函数 → 内部审计部门 """
    print("[内部告示] 正在检查 _内部规定 执行情况...")

# ==================== 4. 创建实例并演示 ====================
if __name__ == "__main__":  # __name__ 是特殊变量 → 公司总控开关
    print("\n=== CEO启动 __main__.py ===")
  
    my_company = 公司("Python科技")  # 触发__init__自动门
    print(my_company)               # 触发__str__宣传屏
  
    # 公共区域自由访问
    my_company.公开操作()            # ✅ 正常使用公共API
  
    # 尝试突破限制
    try:
        print(my_company._内部规定)   # ⚠️ 看到内部告示但可以强行访问
        # print(my_company.__预算)    # ❌ 报错！找不到保险柜
        print(my_company._公司__预算) # 🔑 知道密码才能打开保险柜
    except Exception as e:
        print(f"[警报] 非法入侵！错误信息: {e}")
  
    _内部审计()  # 内部人员知道审计流程
```

---

### 代码运行结果（对应公司场景）

```text
=== 公司开张啦！门口挂上 __init__.py 招牌 ===

=== CEO启动 __main__.py ===
[自动门] 欢迎来到Python科技！
=== 公司公告：禁止摸鱼 ===
[公共区域] 请使用咖啡机
[保险柜] 正在通过 _公司__发工资 流程...
禁止摸鱼
[警报] 非法入侵！错误信息: '公司' object has no attribute '__预算'
[内部告示] 正在检查 _内部规定 执行情况...
```

---

### 关键点解析（对照比喻）

1. **`__init__` 方法**

   - 像自动门，创建公司时自动触发
   - 同时初始化保险柜(`__预算`)和公告栏(`_内部规定`)
2. **`__预算` 属性**

   - 实际存储为 `_公司__预算`（名称改写）
   - 外部直接访问 `__预算`会触发警报（AttributeError）
3. **`_内部规定` 属性**

   - 虽然标记为内部，但外部仍可强行查看
   - 类似茶水间贴的告示，靠自觉遵守
4. **`__str__` 方法**

   - 像公司大厅的电子屏，打印对象时自动显示
   - 控制公司对外的形象展示
5. **`__main__` 作用**

   - 当直接运行 `python company.py` 时
   - 相当于CEO亲自启动公司运营流程

---

通过这个代码公司，你可以直观看到：

- 双下划线如何像**自动化设备**一样工作
- 单下划线如何像**内部告示**提示而非强制
- 名称改写如何像**部门保险柜**保护关键数据
- 无下划线名称如何像**公共区域**自由访问
